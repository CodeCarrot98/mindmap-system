<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Mind Map</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #root {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const MindMapApp = () => {
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [selectedNode, setSelectedNode] = useState(null);
            const [contextMenu, setContextMenu] = useState(null);
            const [editingNode, setEditingNode] = useState(null);
            const [viewBox, setViewBox] = useState({ x: 0, y: 0, width: 1200, height: 800 });
            const [isPanning, setIsPanning] = useState(false);
            const [panStart, setPanStart] = useState({ x: 0, y: 0 });
            const [draggedNode, setDraggedNode] = useState(null);
            const [colorPicker, setColorPicker] = useState(null);
            const [deleteDialog, setDeleteDialog] = useState(null);
            const svgRef = useRef(null);
            const fileInputRef = useRef(null);

            const colors = ['#4A90E2', '#E24A4A', '#4AE290', '#E2C44A', '#9B4AE2', '#E24A9B', '#4AE2E2'];

            useEffect(() => {
                const interval = setInterval(() => {
                    saveToLocalStorage();
                }, 30000);
                return () => clearInterval(interval);
            }, [nodes, connections]);

            useEffect(() => {
                const saved = localStorage.getItem('mindmap-data');
                if (saved) {
                    const data = JSON.parse(saved);
                    setNodes(data.nodes || []);
                    setConnections(data.connections || []);
                }
            }, []);

            const saveToLocalStorage = () => {
                const data = { nodes, connections };
                localStorage.setItem('mindmap-data', JSON.stringify(data));
            };

            const createNode = (x, y, text = 'New Node', parentId = null, color = '#4A90E2') => {
                const newNode = {
                    id: `node-${Date.now()}`,
                    text,
                    x,
                    y,
                    color,
                    collapsed: false,
                    level: 0
                };

                if (parentId) {
                    const parent = nodes.find(n => n.id === parentId);
                    if (parent) {
                        newNode.level = parent.level + 1;
                        newNode.color = lightenColor(parent.color, 0.2);
                        
                        const siblings = connections.filter(c => c.from === parentId).length;
                        newNode.x = parent.x + 200;
                        newNode.y = parent.y + (siblings * 100) - 50;
                        
                        setConnections([...connections, {
                            id: `conn-${Date.now()}`,
                            from: parentId,
                            to: newNode.id
                        }]);
                    }
                }

                setNodes([...nodes, newNode]);
                return newNode.id;
            };

            const lightenColor = (color, amount) => {
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                const newR = Math.min(255, Math.floor(r + (255 - r) * amount));
                const newG = Math.min(255, Math.floor(g + (255 - g) * amount));
                const newB = Math.min(255, Math.floor(b + (255 - b) * amount));
                
                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            };

            const deleteNode = (nodeId, deleteChildren) => {
                if (deleteChildren) {
                    const toDelete = new Set([nodeId]);
                    let changed = true;
                    while (changed) {
                        changed = false;
                        connections.forEach(conn => {
                            if (toDelete.has(conn.from) && !toDelete.has(conn.to)) {
                                toDelete.add(conn.to);
                                changed = true;
                            }
                        });
                    }
                    setNodes(nodes.filter(n => !toDelete.has(n.id)));
                    setConnections(connections.filter(c => !toDelete.has(c.from) && !toDelete.has(c.to)));
                } else {
                    const childConnections = connections.filter(c => c.from === nodeId);
                    const parentConnection = connections.find(c => c.to === nodeId);
                    
                    if (parentConnection) {
                        const newConnections = childConnections.map(c => ({
                            ...c,
                            from: parentConnection.from
                        }));
                        setConnections([
                            ...connections.filter(c => c.from !== nodeId && c.to !== nodeId),
                            ...newConnections
                        ]);
                    } else {
                        setConnections(connections.filter(c => c.from !== nodeId && c.to !== nodeId));
                    }
                    
                    setNodes(nodes.filter(n => n.id !== nodeId));
                }
                setDeleteDialog(null);
            };

            const addChildNode = (parentId) => {
                const parent = nodes.find(n => n.id === parentId);
                if (parent) {
                    createNode(parent.x + 200, parent.y, 'New Child', parentId);
                }
                setContextMenu(null);
            };

            const addParentNode = (childId) => {
                const child = nodes.find(n => n.id === childId);
                if (child) {
                    const newParentId = createNode(child.x - 200, child.y, 'New Parent', null, child.color);
                    setConnections([...connections, {
                        id: `conn-${Date.now()}`,
                        from: newParentId,
                        to: childId
                    }]);
                }
                setContextMenu(null);
            };

            const addSiblingNode = (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                const parentConnection = connections.find(c => c.to === nodeId);
                
                if (parentConnection) {
                    const parent = nodes.find(n => n.id === parentConnection.from);
                    createNode(parent.x + 200, node.y + 100, 'New Sibling', parent.id);
                } else {
                    createNode(node.x, node.y + 100, 'New Sibling', null, node.color);
                }
                setContextMenu(null);
            };

            const toggleCollapse = (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node) return;
                
                const hasChildren = connections.some(c => c.from === nodeId);
                if (!hasChildren) return;
                
                setNodes(nodes.map(n => 
                    n.id === nodeId ? { ...n, collapsed: !n.collapsed } : n
                ));
            };

            const getVisibleNodes = () => {
                const visible = new Set(nodes.map(n => n.id));
                
                nodes.forEach(node => {
                    if (node.collapsed) {
                        const hideDescendants = (parentId) => {
                            connections.forEach(conn => {
                                if (conn.from === parentId) {
                                    visible.delete(conn.to);
                                    hideDescendants(conn.to);
                                }
                            });
                        };
                        hideDescendants(node.id);
                    }
                });
                
                return nodes.filter(n => visible.has(n.id));
            };

            const expandAll = () => {
                setNodes(nodes.map(n => ({ ...n, collapsed: false })));
            };

            const collapseAll = () => {
                const rootNodes = nodes.filter(n => !connections.some(c => c.to === n.id));
                setNodes(nodes.map(n => ({
                    ...n,
                    collapsed: !rootNodes.includes(n) && connections.some(c => c.from === n.id)
                })));
            };

            const handleSvgClick = (e) => {
                if (e.target === svgRef.current || e.target.tagName === 'svg') {
                    setSelectedNode(null);
                    setContextMenu(null);
                }
            };

            const handleContextMenu = (e, nodeId = null) => {
                e.preventDefault();
                const rect = svgRef.current.getBoundingClientRect();
                setContextMenu({
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    nodeId
                });
            };

            const handleMouseDown = (e, nodeId) => {
                if (e.button === 0) {
                    setDraggedNode({ id: nodeId, startX: e.clientX, startY: e.clientY });
                    setSelectedNode(nodeId);
                }
            };

            const handleMouseMove = (e) => {
                if (draggedNode) {
                    const dx = (e.clientX - draggedNode.startX) * (viewBox.width / svgRef.current.clientWidth);
                    const dy = (e.clientY - draggedNode.startY) * (viewBox.height / svgRef.current.clientHeight);
                    
                    setNodes(nodes.map(n => 
                        n.id === draggedNode.id 
                            ? { ...n, x: n.x + dx, y: n.y + dy }
                            : n
                    ));
                    
                    setDraggedNode({ ...draggedNode, startX: e.clientX, startY: e.clientY });
                } else if (isPanning) {
                    const dx = (e.clientX - panStart.x) * (viewBox.width / svgRef.current.clientWidth);
                    const dy = (e.clientY - panStart.y) * (viewBox.height / svgRef.current.clientHeight);
                    
                    setViewBox({
                        ...viewBox,
                        x: viewBox.x - dx,
                        y: viewBox.y - dy
                    });
                    
                    setPanStart({ x: e.clientX, y: e.clientY });
                }
            };

            const handleMouseUp = () => {
                setDraggedNode(null);
                setIsPanning(false);
            };

            const handleWheel = (e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                setViewBox({
                    ...viewBox,
                    width: viewBox.width * scale,
                    height: viewBox.height * scale
                });
            };

            const changeNodeColor = (nodeId, color) => {
                const updateNodeColors = (id, baseColor, level = 0) => {
                    const currentColor = level === 0 ? baseColor : lightenColor(baseColor, 0.2 * level);
                    
                    setNodes(prev => prev.map(n => 
                        n.id === id ? { ...n, color: currentColor, level } : n
                    ));
                    
                    connections
                        .filter(c => c.from === id)
                        .forEach(conn => updateNodeColors(conn.to, baseColor, level + 1));
                };
                
                updateNodeColors(nodeId, color);
                setColorPicker(null);
                setContextMenu(null);
            };

            const exportToJSON = () => {
                const data = {
                    nodes,
                    connections,
                    exportDate: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const importFromJSON = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        setNodes(data.nodes || []);
                        setConnections(data.connections || []);
                    } catch (error) {
                        alert('Invalid JSON file');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            };

            const visibleNodes = getVisibleNodes();

            return (
                <div className="w-full h-screen flex flex-col bg-gray-50">
                    <div className="bg-white border-b border-gray-200 px-4 py-3 flex items-center gap-2 flex-wrap">
                        <button
                            onClick={() => createNode(viewBox.x + viewBox.width / 2, viewBox.y + viewBox.height / 2)}
                            className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            Add Root Node
                        </button>
                        
                        <button
                            onClick={expandAll}
                            className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <polyline points="15 3 21 3 21 9"></polyline>
                                <polyline points="9 21 3 21 3 15"></polyline>
                                <line x1="21" y1="3" x2="14" y2="10"></line>
                                <line x1="3" y1="21" x2="10" y2="14"></line>
                            </svg>
                            Expand All
                        </button>
                        
                        <button
                            onClick={collapseAll}
                            className="flex items-center gap-2 px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <polyline points="4 14 10 14 10 20"></polyline>
                                <polyline points="20 10 14 10 14 4"></polyline>
                                <line x1="14" y1="10" x2="21" y2="3"></line>
                                <line x1="3" y1="21" x2="10" y2="14"></line>
                            </svg>
                            Collapse All
                        </button>
                        
                        <div className="flex-1" />
                        
                        <button
                            onClick={saveToLocalStorage}
                            className="flex items-center gap-2 px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 transition"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                <polyline points="7 3 7 8 15 8"></polyline>
                            </svg>
                            Save
                        </button>
                        
                        <button
                            onClick={exportToJSON}
                            className="flex items-center gap-2 px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Export JSON
                        </button>
                        
                        <button
                            onClick={() => fileInputRef.current?.click()}
                            className="flex items-center gap-2 px-4 py-2 bg-teal-500 text-white rounded hover:bg-teal-600 transition"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                            Import JSON
                        </button>
                        
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept=".json"
                            onChange={importFromJSON}
                            style={{ display: 'none' }}
                        />
                    </div>

                    <div className="flex-1 relative overflow-hidden">
                        <svg
                            ref={svgRef}
                            className="w-full h-full cursor-move"
                            viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`}
                            onClick={handleSvgClick}
                            onContextMenu={(e) => handleContextMenu(e)}
                            onMouseDown={(e) => {
                                if (e.button === 0 && e.target === svgRef.current) {
                                    setIsPanning(true);
                                    setPanStart({ x: e.clientX, y: e.clientY });
                                }
                            }}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                            onWheel={handleWheel}
                        >
                            <defs>
                                <filter id="shadow">
                                    <feDropShadow dx="0" dy="2" stdDeviation="3" floodOpacity="0.3" />
                                </filter>
                            </defs>

                            {connections.map(conn => {
                                const fromNode = visibleNodes.find(n => n.id === conn.from);
                                const toNode = visibleNodes.find(n => n.id === conn.to);
                                if (!fromNode || !toNode) return null;

                                const midX = (fromNode.x + toNode.x) / 2;
                                
                                return (
                                    <path
                                        key={conn.id}
                                        d={`M ${fromNode.x + 100} ${fromNode.y + 25} C ${midX} ${fromNode.y + 25}, ${midX} ${toNode.y + 25}, ${toNode.x} ${toNode.y + 25}`}
                                        stroke={fromNode.color}
                                        strokeWidth="2"
                                        fill="none"
                                        opacity="0.6"
                                    />
                                );
                            })}

                            {visibleNodes.map(node => {
                                const hasChildren = connections.some(c => c.from === node.id);
                                
                                return (
                                    <g
                                        key={node.id}
                                        transform={`translate(${node.x}, ${node.y})`}
                                        onMouseDown={(e) => handleMouseDown(e, node.id)}
                                        onContextMenu={(e) => handleContextMenu(e, node.id)}
                                        style={{ cursor: 'pointer' }}
                                    >
                                        <rect
                                            width="100"
                                            height="50"
                                            rx="8"
                                            fill={node.color}
                                            stroke={selectedNode === node.id ? '#000' : 'none'}
                                            strokeWidth="2"
                                            filter="url(#shadow)"
                                        />
                                        
                                        <text
                                            x="50"
                                            y="25"
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            fill="white"
                                            fontSize="12"
                                            fontWeight="500"
                                            style={{ pointerEvents: 'none', userSelect: 'none' }}
                                        >
                                            {node.text.length > 12 ? node.text.substring(0, 12) + '...' : node.text}
                                        </text>

                                        {hasChildren && (
                                            <g
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    toggleCollapse(node.id);
                                                }}
                                                style={{ cursor: 'pointer' }}
                                            >
                                                <circle
                                                    cx="90"
                                                    cy="25"
                                                    r="8"
                                                    fill="white"
                                                    stroke={node.color}
                                                    strokeWidth="2"
                                                />
                                                <text
                                                    x="90"
                                                    y="25"
                                                    textAnchor="middle"
                                                    dominantBaseline="middle"
                                                    fontSize="12"
                                                    fontWeight="bold"
                                                    fill={node.color}
                                                >
                                                    {node.collapsed ? '+' : '−'}
                                                </text>
                                            </g>
                                        )}
                    </div>

                    <div className="bg-white border-t border-gray-200 px-4 py-2 text-xs text-gray-600">
                        <span className="font-semibold">Controls:</span> Right-click on canvas to create root node • Right-click on node for options • Drag nodes to move • Scroll to zoom • Drag canvas to pan • Click +/− to collapse/expand
                    </div>
                </div>
            );
        };

        ReactDOM.render(<MindMapApp />, document.getElementById('root'));
    </script>
</body>
</html>
                                    </g>
                                );
                            })}
                        </svg>

                        {contextMenu && (
                            <div
                                className="absolute bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50 min-w-[160px]"
                                style={{
                                    left: contextMenu.x,
                                    top: contextMenu.y
                                }}
                            >
                                {contextMenu.nodeId ? (
                                    <>
                                        <button
                                            onClick={() => addChildNode(contextMenu.nodeId)}
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                                        >
                                            Add Child
                                        </button>
                                        <button
                                            onClick={() => addParentNode(contextMenu.nodeId)}
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                                        >
                                            Add Parent
                                        </button>
                                        <button
                                            onClick={() => addSiblingNode(contextMenu.nodeId)}
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                                        >
                                            Add Sibling
                                        </button>
                                        <div className="border-t border-gray-200 my-1" />
                                        <button
                                            onClick={() => {
                                                setEditingNode(contextMenu.nodeId);
                                                setContextMenu(null);
                                            }}
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                                        >
                                            Edit Text
                                        </button>
                                        <button
                                            onClick={() => {
                                                setColorPicker(contextMenu.nodeId);
                                                setContextMenu(null);
                                            }}
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                                        >
                                            Change Color
                                        </button>
                                        <div className="border-t border-gray-200 my-1" />
                                        <button
                                            onClick={() => {
                                                const hasChildren = connections.some(c => c.from === contextMenu.nodeId);
                                                if (hasChildren) {
                                                    setDeleteDialog(contextMenu.nodeId);
                                                    setContextMenu(null);
                                                } else {
                                                    deleteNode(contextMenu.nodeId, true);
                                                    setContextMenu(null);
                                                }
                                            }}
                                            className="w-full text-left px-4 py-2 hover:bg-red-50 text-red-600 text-sm"
                                        >
                                            Delete
                                        </button>
                                    </>
                                ) : (
                                    <button
                                        onClick={() => {
                                            createNode(contextMenu.x + viewBox.x, contextMenu.y + viewBox.y);
                                            setContextMenu(null);
                                        }}
                                        className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                                    >
                                        Create Root Node
                                    </button>
                                )}
                            </div>
                        )}

                        {editingNode && (
                            <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-lg p-6 w-80 shadow-xl">
                                    <h3 className="text-lg font-semibold mb-4">Edit Node Text</h3>
                                    <input
                                        type="text"
                                        defaultValue={nodes.find(n => n.id === editingNode)?.text}
                                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                                        autoFocus
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter') {
                                                setNodes(nodes.map(n => 
                                                    n.id === editingNode ? { ...n, text: e.target.value } : n
                                                ));
                                                setEditingNode(null);
                                            } else if (e.key === 'Escape') {
                                                setEditingNode(null);
                                            }
                                        }}
                                    />
                                    <div className="flex gap-2 mt-4">
                                        <button
                                            onClick={(e) => {
                                                const input = e.target.parentElement.previousSibling;
                                                setNodes(nodes.map(n => 
                                                    n.id === editingNode ? { ...n, text: input.value } : n
                                                ));
                                                setEditingNode(null);
                                            }}
                                            className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                            Save
                                        </button>
                                        <button
                                            onClick={() => setEditingNode(null)}
                                            className="flex-1 px-4 py-2 bg-gray-300 rounded hover:bg-gray-400"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {colorPicker && (
                            <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-lg p-6 w-80 shadow-xl">
                                    <h3 className="text-lg font-semibold mb-4">Choose Color</h3>
                                    <div className="grid grid-cols-4 gap-3">
                                        {colors.map(color => (
                                            <button
                                                key={color}
                                                onClick={() => changeNodeColor(colorPicker, color)}
                                                className="w-full h-12 rounded-lg border-2 border-gray-200 hover:border-gray-400 transition"
                                                style={{ backgroundColor: color }}
                                            />
                                        ))}
                                    </div>
                                    <button
                                        onClick={() => setColorPicker(null)}
                                        className="w-full mt-4 px-4 py-2 bg-gray-300 rounded hover:bg-gray-400"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}

                        {deleteDialog && (
                            <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-lg p-6 w-96 shadow-xl">
                                    <h3 className="text-lg font-semibold mb-2">Delete Node</h3>
                                    <p className="text-gray-600 mb-6">This node has children. What would you like to do?</p>
                                    <div className="flex flex-col gap-2">
                                        <button
                                            onClick={() => deleteNode(deleteDialog, true)}
                                            className="w-full px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                                        >
                                            Delete node and all children
                                        </button>
                                        <button
                                            onClick={() => deleteNode(deleteDialog, false)}
                                            className="w-full px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600"
                                        >
                                            Delete node only (promote children)
                                        </button>
                                        <button
                                            onClick={() => setDeleteDialog(null)}
                                            className="w-full px-4 py-2 bg-gray-300 rounded hover:bg-gray-400"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
